import jsep from 'jsep';
import jsepObject from '@jsep-plugin/object';
import { NODE_TYPES, MDX_JSX_ATTRIBUTE_TYPES } from './constants';
import { TagPluginRegistry } from './tag-plugin-registry';
import { hasFunctionBody, getFunctionBody } from './ast-utils';
import { stringifyValue } from './utils';
import { isMdxJsxElement, isMdxJsxFlowElement, isMdxJsxTextElement, isParentNode, } from './ast-utils';
import { FilterRegistry } from './filter-registry';
import { Scope } from './scope';
import { mdxToMarkdown } from "mdast-util-mdx";
import { toMarkdown } from 'mdast-util-to-markdown';
jsep.plugins.register(jsepObject);
const options = {
    extensions: [mdxToMarkdown()],
};
const toMdxMarkdown = (node) => {
    return toMarkdown(node, options);
};
const nodeHelpers = {
    isMdxJsxElement,
    isMdxJsxFlowElement,
    isMdxJsxTextElement,
    isParentNode,
    toMarkdown: toMdxMarkdown,
    hasFunctionBody,
    getFunctionBody,
    NODE_TYPES,
};
export class NodeTransformer {
    constructor(scope) {
        this.scope = scope;
    }
    async transformNode(node) {
        if (node.type === NODE_TYPES.MDX_TEXT_EXPRESSION ||
            node.type === NODE_TYPES.MDX_FLOW_EXPRESSION) {
            return this.evaluateExpressionNode(node);
        }
        if (isMdxJsxElement(node)) {
            return await this.processMdxJsxElement(node);
        }
        if (this.isFragmentNode(node)) {
            const processedChildren = await Promise.all(node.children.map(async (child) => {
                const childTransformer = new NodeTransformer(this.scope);
                const result = await childTransformer.transformNode(child);
                return Array.isArray(result) ? result : [result];
            }));
            return processedChildren.flat();
        }
        if (isParentNode(node)) {
            const newNode = { ...node };
            const processedChildren = await Promise.all(node.children.map(async (child) => {
                const childTransformer = new NodeTransformer(this.scope);
                const result = await childTransformer.transformNode(child);
                return Array.isArray(result) ? result : [result];
            }));
            newNode.children = processedChildren.flat();
            return newNode;
        }
        return node;
    }
    isFragmentNode(node) {
        return (isMdxJsxElement(node) &&
            (node.name === null ||
                node.name === '' ||
                node.name === 'Fragment' ||
                node.name === 'React.Fragment'));
    }
    evaluateExpressionNode(node) {
        const expression = node.value;
        try {
            const evaluatedValue = this.resolveExpression(expression);
            return {
                type: NODE_TYPES.TEXT,
                value: stringifyValue(evaluatedValue),
            };
        }
        catch (error) {
            throw new Error(`Error evaluating expression "${expression}": ${error.message}`);
        }
    }
    resolveExpression(expression) {
        expression = expression.trim();
        let ast;
        try {
            ast = jsep(expression);
        }
        catch (e) {
            throw new Error(`Failed to parse expression: "${expression}"`);
        }
        return this.evaluateJsepExpression(ast);
    }
    evaluateJsepExpression(node) {
        switch (node.type) {
            case 'BinaryExpression':
                return this.evaluateBinaryExpression(node);
            case 'UnaryExpression':
                return this.evaluateUnaryExpression(node);
            case 'Literal':
                return node.value;
            case 'Identifier':
                return this.resolveVariable(node.name);
            case 'MemberExpression':
                return this.evaluateMemberExpression(node);
            case 'CallExpression':
                return this.evaluateCallExpression(node);
            case 'ArrayExpression':
                return this.evaluateArrayExpression(node);
            case 'ObjectExpression':
                return this.evaluateObjectExpression(node);
            default:
                throw new Error(`Unsupported node type: ${node.type}`);
        }
    }
    evaluateArrayExpression(node) {
        return node.elements.map((element) => this.evaluateJsepExpression(element));
    }
    evaluateObjectExpression(node) {
        const obj = {};
        for (const property of node.properties) {
            let key;
            if (property.key.type === 'Identifier') {
                key = property.key.name;
            }
            else if (property.key.type === 'Literal') {
                key = property.key.value;
            }
            else {
                throw new Error(`Unsupported object key type: ${property.key.type}`);
            }
            const value = this.evaluateJsepExpression(property.value);
            obj[key] = value;
        }
        return obj;
    }
    evaluateCallExpression(node) {
        const callee = node.callee;
        if (callee.type !== 'Identifier') {
            throw new Error(`Only calls to registered filters are allowed.`);
        }
        const functionName = callee.name;
        const filterFunction = FilterRegistry.get(functionName);
        if (!filterFunction) {
            throw new Error(`Filter "${functionName}" is not registered.`);
        }
        const args = node.arguments.map(arg => this.evaluateJsepExpression(arg));
        const [input, ...rest] = args;
        return filterFunction(input, ...rest);
    }
    resolveVariable(variablePath) {
        if (!variablePath) {
            throw new Error(`Variable path cannot be empty.`);
        }
        const parts = variablePath.split('.');
        let value;
        try {
            value = this.scope.get(parts[0]);
        }
        catch (error) {
            throw new Error(`Variable "${parts[0]}" is not defined in the scope.`);
        }
        for (let i = 1; i < parts.length; i++) {
            const part = parts[i];
            if (value == null) {
                throw new Error(`Cannot access property "${part}" of null or undefined in "${variablePath}".`);
            }
            value = value[part];
        }
        return value;
    }
    evaluateBinaryExpression(node) {
        const operatorFunctions = {
            '+': (left, right) => left + this.evaluateJsepExpression(right),
            '-': (left, right) => left - this.evaluateJsepExpression(right),
            '*': (left, right) => left * this.evaluateJsepExpression(right),
            '/': (left, right) => left / this.evaluateJsepExpression(right),
            '%': (left, right) => left % this.evaluateJsepExpression(right),
            '==': (left, right) => left == this.evaluateJsepExpression(right),
            '!=': (left, right) => left != this.evaluateJsepExpression(right),
            '>': (left, right) => left > this.evaluateJsepExpression(right),
            '>=': (left, right) => left >= this.evaluateJsepExpression(right),
            '<': (left, right) => left < this.evaluateJsepExpression(right),
            '<=': (left, right) => left <= this.evaluateJsepExpression(right),
            '&&': (left, right) => left && this.evaluateJsepExpression(right),
            '||': (left, right) => left || this.evaluateJsepExpression(right),
        };
        const operator = node.operator;
        const operation = operatorFunctions[operator];
        if (!operation) {
            throw new Error(`Operator "${operator}" is not allowed.`);
        }
        const left = this.evaluateJsepExpression(node.left);
        return operation(left, node.right);
    }
    evaluateUnaryExpression(node) {
        const argument = this.evaluateJsepExpression(node.argument);
        switch (node.operator) {
            case '+':
                return +argument;
            case '-':
                return -argument;
            case '!':
                return !argument;
            default:
                throw new Error(`Unsupported operator: ${node.operator}`);
        }
    }
    evaluateMemberExpression(node) {
        const object = this.evaluateJsepExpression(node.object);
        const property = node.computed
            ? this.evaluateJsepExpression(node.property)
            : node.property.name;
        if (object && typeof object === 'object' && property in object) {
            if (object[property] === undefined)
                return '';
            return object[property];
        }
        else {
            return '';
        }
    }
    async processMdxJsxElement(node) {
        try {
            const tagName = node.name;
            const plugin = TagPluginRegistry.get(tagName);
            if (plugin) {
                const props = this.evaluateProps(node);
                const pluginContext = {
                    createNodeTransformer: (scope) => new NodeTransformer(scope),
                    scope: this.scope,
                    tagName,
                    nodeHelpers,
                };
                const result = await plugin.transform(props, node.children, pluginContext);
                return result;
            }
            else {
                const newNode = { ...node };
                const processedChildren = await Promise.all(node.children.map(async (child) => {
                    const childTransformer = new NodeTransformer(this.scope);
                    const result = await childTransformer.transformNode(child);
                    return Array.isArray(result) ? result : [result];
                }));
                newNode.children = processedChildren.flat();
                return newNode;
            }
        }
        catch (error) {
            throw new Error(`Error processing MDX JSX Element: ${error.message}`);
        }
    }
    evaluateProps(node) {
        const props = {};
        for (const attr of node.attributes) {
            if (attr.type === MDX_JSX_ATTRIBUTE_TYPES.MDX_JSX_ATTRIBUTE) {
                if (attr.value === null || typeof attr.value === 'string') {
                    props[attr.name] = attr.value || '';
                }
                else if (attr.value.type ===
                    MDX_JSX_ATTRIBUTE_TYPES.MDX_JSX_ATTRIBUTE_VALUE_EXPRESSION) {
                    const expression = attr.value.value;
                    props[attr.name] = this.resolveExpression(expression);
                }
            }
            else if (attr.type === MDX_JSX_ATTRIBUTE_TYPES.MDX_JSX_EXPRESSION_ATTRIBUTE) {
                throw new Error(`Unsupported attribute type in component <${node.name}>.`);
            }
        }
        return props;
    }
}
export const transformTree = async (tree, props = {}, shared = {}) => {
    const scope = new Scope({ props }, shared);
    const transformer = new NodeTransformer(scope);
    const processedTree = await transformer.transformNode(tree);
    return processedTree;
};
//# sourceMappingURL=transformer.js.map