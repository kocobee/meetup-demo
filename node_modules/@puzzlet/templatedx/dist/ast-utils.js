import { NODE_TYPES } from './constants';
import { unified } from 'unified';
import yaml from 'js-yaml';
import remarkParse from 'remark-parse';
import remarkMdx from 'remark-mdx';
import remarkFrontmatter from 'remark-frontmatter';
import remarkStringify from 'remark-stringify';
export const createBaseProcessor = () => unified().use(remarkParse).use(remarkMdx).use(remarkFrontmatter);
export function isMdxJsxElement(node) {
    return isMdxJsxFlowElement(node) || isMdxJsxTextElement(node);
}
export function isMdxJsxFlowElement(node) {
    return node.type === NODE_TYPES.MDX_JSX_FLOW_ELEMENT;
}
export function isMdxJsxTextElement(node) {
    return node.type === NODE_TYPES.MDX_JSX_TEXT_ELEMENT;
}
export function isParentNode(node) {
    return 'children' in node && Array.isArray(node.children);
}
export function compressAst(node) {
    const propertiesToDelete = [
        'position',
        'start',
        'end',
        'loc',
        'range',
        'data',
        'meta',
        'raw',
        'extra',
        'comments',
    ];
    for (const prop of propertiesToDelete) {
        if (prop in node) {
            delete node[prop];
        }
    }
    if (Array.isArray(node.children)) {
        for (const child of node.children) {
            compressAst(child);
        }
    }
    if (Array.isArray(node.attributes)) {
        for (const attr of node.attributes) {
            compressAst(attr);
        }
    }
    for (const key in node) {
        if (node.hasOwnProperty(key) &&
            typeof node[key] === 'object' &&
            node[key] !== null) {
            compressAst(node[key]);
        }
    }
}
export const getFrontMatter = (tree) => {
    const frontmatterNode = tree.children.find((node) => node.type === NODE_TYPES.YAML);
    return yaml.load((frontmatterNode === null || frontmatterNode === void 0 ? void 0 : frontmatterNode.value) || '');
};
export function parse(mdxContent) {
    const processor = unified().use(remarkParse).use(remarkMdx).use(remarkFrontmatter);
    return processor.parse(mdxContent);
}
export const stringify = (tree) => {
    const processor = createBaseProcessor().use(remarkStringify);
    return String(processor.stringify(tree));
};
export function hasFunctionBody(childNode) {
    var _a;
    if (childNode.type !== 'mdxFlowExpression') {
        return false;
    }
    const estree = (_a = childNode.data) === null || _a === void 0 ? void 0 : _a.estree;
    if (!estree || estree.body.length === 0) {
        return false;
    }
    const expression = estree.body[0].expression;
    return expression.type === 'ArrowFunctionExpression';
}
export function getFunctionBody(childNode) {
    var _a;
    if (childNode.type !== 'mdxFlowExpression') {
        throw new Error('Expected a function as the child.');
    }
    const functionCode = childNode.value;
    const estree = (_a = childNode.data) === null || _a === void 0 ? void 0 : _a.estree;
    if (!estree || estree.body.length === 0) {
        throw new Error('Invalid function expression.');
    }
    const functionExpression = estree.body[0].expression;
    if (functionExpression.type !== 'ArrowFunctionExpression') {
        throw new Error('Child must be an arrow function.');
    }
    const params = functionExpression.params;
    const argumentNames = params.map((param) => {
        if (param.type === 'Identifier') {
            return param.name;
        }
        else {
            throw new Error('Only simple identifiers are supported as function parameters.');
        }
    });
    if (argumentNames.length < 1) {
        throw new Error('Function must have at least one parameter.');
    }
    const arrowIndex = functionCode.indexOf('=>');
    if (arrowIndex === -1) {
        throw new Error('Invalid function expression.');
    }
    let functionBodyCode = functionCode.substring(arrowIndex + 2).trim();
    if (functionBodyCode.startsWith('(') && functionBodyCode.endsWith(')')) {
        functionBodyCode = functionBodyCode.substring(1, functionBodyCode.length - 1).trim();
    }
    const functionBodyTree = parse(functionBodyCode);
    const unwrappedNodes = unwrapFragments(functionBodyTree.children);
    return { body: unwrappedNodes, argumentNames };
}
function unwrapFragments(nodes) {
    const unwrappedNodes = [];
    for (const node of nodes) {
        if (isFragmentNode(node)) {
            if (node.children) {
                const childNodes = unwrapFragments(node.children);
                unwrappedNodes.push(...childNodes);
            }
        }
        else {
            unwrappedNodes.push(node);
        }
    }
    return unwrappedNodes;
}
function isFragmentNode(node) {
    return (node.type === NODE_TYPES.MDX_JSX_FLOW_ELEMENT &&
        node.name === null);
}
//# sourceMappingURL=ast-utils.js.map