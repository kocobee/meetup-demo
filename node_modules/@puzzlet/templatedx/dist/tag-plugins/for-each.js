import { TagPlugin } from '../tag-plugin';
export const Tags = ['ForEach'];
export class ForEachPlugin extends TagPlugin {
    async transform(props, children, context) {
        const { scope, createNodeTransformer, nodeHelpers } = context;
        const { hasFunctionBody, getFunctionBody, NODE_TYPES } = nodeHelpers;
        function areAllListItems(resultNodesPerItem) {
            return resultNodesPerItem.every((processedNodes) => processedNodes.every((n) => n.type === NODE_TYPES.LIST || n.type === NODE_TYPES.LIST_ITEM));
        }
        function collectListItems(resultNodesPerItem) {
            return resultNodesPerItem.flatMap((processedNodes) => processedNodes.flatMap((n) => {
                if (n.type === NODE_TYPES.LIST) {
                    return n.children;
                }
                else if (n.type === NODE_TYPES.LIST_ITEM) {
                    return n;
                }
                else {
                    return [];
                }
            }));
        }
        if (children.length !== 1) {
            throw new Error(`ForEach expects exactly one child function.`);
        }
        const childNode = children[0];
        if (!hasFunctionBody(childNode)) {
            throw new Error('ForEach expects a function as its child.');
        }
        const { body, argumentNames } = getFunctionBody(childNode);
        const arr = props['arr'];
        if (!Array.isArray(arr)) {
            throw new Error(`The 'arr' prop for <ForEach> must be an array.`);
        }
        const itemParamName = argumentNames[0];
        const indexParamName = argumentNames[1];
        const resultNodesPerItem = await Promise.all(arr.map(async (item, index) => {
            const itemScope = scope.createChild({
                ...(itemParamName && { [itemParamName]: item }),
                ...(indexParamName && { [indexParamName]: index }),
            });
            const itemTransformer = createNodeTransformer(itemScope);
            const processedChildren = await Promise.all(body.map(async (child) => {
                const result = await itemTransformer.transformNode(child);
                return Array.isArray(result) ? result : [result];
            }));
            return processedChildren.flat();
        }));
        const resultNodes = resultNodesPerItem.flat();
        if (areAllListItems(resultNodesPerItem)) {
            return [
                {
                    type: NODE_TYPES.LIST,
                    ordered: false,
                    spread: false,
                    children: collectListItems(resultNodesPerItem),
                },
            ];
        }
        else {
            return resultNodes;
        }
    }
}
//# sourceMappingURL=for-each.js.map