import { TagPluginRegistry, transform, getFrontMatter } from "@puzzlet/templatedx";
import { ModelPluginRegistry } from "./model-plugin-registry";
import { ExtractTextPlugin } from "./templatedx-plugins/extract-text";
;
TagPluginRegistry.register(new ExtractTextPlugin(), ["User", "System", "Assistant"]);
async function loadMdx(ast, props = {}) {
    const frontMatter = getFrontMatter(ast);
    const shared = {};
    await transform(ast, props, shared);
    const extractedFields = shared.extractedText || [];
    const messages = extractedFields.map((field) => ({ role: field.name.toLocaleLowerCase(), content: field.content }));
    if (!frontMatter.metadata)
        throw new Error(`Prompt must contain metadata`);
    if (!frontMatter.name)
        throw new Error(`Prompt must have a name`);
    if (!extractedFields.length)
        throw new Error(`Prompt messages must not be empty.`);
    if (!frontMatter.metadata.model)
        throw new Error(`Prompt metadata must contain model info`);
    const promptDX = {
        name: frontMatter.name,
        messages: messages,
        metadata: frontMatter.metadata,
    };
    return promptDX;
}
export async function runInference(ast, props = {}) {
    const promptDX = await loadMdx(ast, props);
    const plugin = ModelPluginRegistry.getPlugin(promptDX.metadata.model.name);
    return plugin === null || plugin === void 0 ? void 0 : plugin.run(promptDX);
}
export function serialize(completionParams, model, promptName) {
    const plugin = ModelPluginRegistry.getPlugin(model);
    return plugin === null || plugin === void 0 ? void 0 : plugin.serialize(completionParams, promptName);
}
export async function deserialize(ast, props = {}) {
    const promptDX = await loadMdx(ast, props);
    const plugin = ModelPluginRegistry.getPlugin(promptDX.metadata.model.name);
    return plugin === null || plugin === void 0 ? void 0 : plugin.deserialize(promptDX);
}
export const registerDefaultPlugins = async () => {
    return await import("./builtin-plugins");
};
export const getModel = (ast) => {
    const frontMatter = getFrontMatter(ast);
    return frontMatter.metadata.model.name;
};
//# sourceMappingURL=runtime.js.map